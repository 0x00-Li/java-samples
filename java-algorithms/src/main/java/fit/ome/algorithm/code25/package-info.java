package fit.ome.algorithm.code25;

/**
 * 单调栈
 *一种特别设计的栈结构，为了解决如下的问题：
 *
 * 给定一个可能含有重复值的数组arr，i位置的数一定存在如下两个信息
 * 1）arr[i]的左侧离i最近并且小于(或者大于)arr[i]的数在哪？
 * 2）arr[i]的右侧离i最近并且小于(或者大于)arr[i]的数在哪？
 * 如果想得到arr中所有位置的两个信息，怎么能让得到信息的过程尽量快。
 *
 *
 * 最小单调栈
 * 本质求指定数值位置两侧最近最小边界
 *
 * 实现步骤:
 * 从简考虑，假定数组中午重复值
 * 1. 一定要从栈低到栈顶，是从小到大的
 * 2. 从左向右遍历，遍历过程中，当前index位置的数，小于了栈顶值，栈顶弹出
 * 3. 栈顶弹出的时候，最右侧的小值，就是当前的值，左侧最近最小的值就是压在弹出元素下方的值
 * 4. 最后把栈里的元素单独弹出，注意：因为没有比栈中的元素的数出现所以，右侧没有最小的值，左侧最小是压在下方的数
 *
 * 流程证明
 *
 * 某一步，b下面压着a，b的出现导致要弹出b，此刻生成b的信息
 * 数组中b在c的左侧
 * b和c中间没数，所以c<b ,所以b的最有最小是c
 *
 * 为什么b的最左最小是a？
 * < a 会把a释放
 * a< ? < b 那么ab不会挨着
 * 所有 b> a
 *
 *
 * 最大单调栈
 *
 * 本质求指定数值两侧最大最近边界
 *
 */